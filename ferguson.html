<!doctype html>
<html lang="en">
    <head>
        <title>Repeating Textures (Three.js)</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>
        <script type="text/javascript" src="js/jquery-1.9.1.js"></script>

        <!--[if IE]><script type="text/javascript" src="excanvas.js"></script><![endif]-->
        <script type="text/javascript" src="js/canvg/rgbcolor.js"></script>
        <script type="text/javascript" src="js/canvg/StackBlur.js"></script>
        <script type="text/javascript" src="js/canvg/canvg.js"></script>

        <script src="js/Three.js"></script>
        <script src="js/Detector.js"></script>
        <!--<script src="js/Stats.js"></script>-->
        <script src="js/OrbitControls.js"></script>
        <script src="js/THREEx.KeyboardState.js"></script>
        <script src="js/THREEx.FullScreen.js"></script>
        <script src="js/THREEx.WindowResize.js"></script>

        <div id="ThreeJS" style="position: absolute; left:0px; top:0px; width: 755px; height: 600px; background-color: #c4c4c4;"></div>
        <div id="canvas_container" style="position: absolute; left: 755px; top: 0px;"></div>
        <script>

            $jq = jQuery.noConflict();

            var pipingImg = 'piping.png';
            var zoomRatio = 50;
            var tierHeight = 7.5 * zoomRatio;
            var cakeSizes = {
                square: {
                    one: {
                        small: [16],
                        standard: [22],
                        medium: [25]
                    },
                    two: {
                        small: [22, 16],
                        medium: [25, 22]
                    },
                    three: {
                        small: [25, 22, 16]
                    }
                },
                round: {
                    one: {
                        mini: [15],
                        small: [18],
                        standard: [20],
                        medium: [25]
                    },
                    two: {
                        small: [18, 15],
                        medium: [20, 18]
                    },
                    three: {
                        small: [20, 18, 15],
                        medium: [25, 20, 18]
                    }
                },
                rectangle: {
                    one: {
                        medium: [20, 33],
                        large: [22, 43],
                        giant: [43, 67]
                    }
                }
            };

            // MAIN

            // standard global variables
            var container, scene, camera, renderer, controls, stats;
            var keyboard = new THREEx.KeyboardState();
            var clock = new THREE.Clock();
            // custom global variables
            var cube;

            init();
            animate();
            // FUNCTIONS 		
            function init()
            {
                // SCENE
                scene = new THREE.Scene();
                // CAMERA
//                	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
                var SCREEN_WIDTH = 755, SCREEN_HEIGHT = 600;
                var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
                camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                scene.add(camera);
                camera.position.set(30 * zoomRatio, 30 * zoomRatio, 40 * zoomRatio);
                camera.lookAt(scene.position);
                // RENDERER
                if (Detector.webgl) {
                    renderer = new THREE.WebGLRenderer({antialias: true});
                } else {
                    renderer = new THREE.CanvasRenderer();
                }
                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                container = document.getElementById('ThreeJS');
                container.appendChild(renderer.domElement);
                // EVENTS
                THREEx.WindowResize(renderer, camera);
                THREEx.FullScreen.bindKey({charCode: 'm'.charCodeAt(0)});
                // CONTROLS
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                // STATS
                //	stats = new Stats();
                //	stats.domElement.style.position = 'absolute';
                //	stats.domElement.style.bottom = '0px';
                //	stats.domElement.style.zIndex = 100;
                //	container.appendChild( stats.domElement );
                // LIGHT
                var light = new THREE.PointLight(0xffffff);
                light.position.set(0, 150, 100);
//                scene.add(light);
                // FLOOR
                //	var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
                //	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
                //	floorTexture.repeat.set( 10, 10 );
                //	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
                //	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                //	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                //	floor.position.y = -0.5;
                //	floor.rotation.x = Math.PI / 2;
                //	scene.add(floor);
                // SKYBOX/FOG
//                	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
//                	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
//                	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
//                	// scene.add(skyBox);
//                	scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );

                ////////////
                // CUSTOM //
                ////////////

                // Spheres
                //   Note: a standard flat rectangular image will look distorted,
                //   a "spherical projection" image will look "normal".

                // radius, segmentsWidth, segmentsHeight
//                var sphereGeom = new THREE.SphereGeometry(40, 32, 16);

                var light2 = new THREE.AmbientLight(0xfffffff);
//                light2.position.set(0, 150, 100);
                scene.add(light2);

                //RECTANGLE CAKES
                var rectangleCakeData = new Array();
                rectangleCakeData['1'] = {
                    size: [67, 43],
                    side: 'side_3.jpg',
                    pipingColor: '#ffffff',
                    pipingSize: '1.5'
                };
//                createRectangleCake(rectangleCakeData);

                //SQUARE CAKES 
                var squareCakeData = new Array();
                squareCakeData['1'] = {
                    size: [25],
                    side: 'side_1.png',
                    pipingColor: '#ffffff',
                    pipingSize: '1.2'
                };
                squareCakeData['2'] = {
                    size: [22],
                    side: 'side_2.png',
                    pipingColor: '#0000ff',
                    pipingSize: '1'
                };
                squareCakeData['3'] = {
                    size: [16],
                    side: 'side_3.jpg',
                    pipingColor: '#ff0000',
                    pipingSize: '0.8'
                };
//                createSquareCake(squareCakeData);


                //ROUND CAKES 
                var roundCakeData = new Array();
                roundCakeData['1'] = {
                    size: [22],
                    side: 'side_1.png',
                    pipingColor: '#ffffff',
                    pipingSize: '1.2'
                };
                roundCakeData['2'] = {
                    size: [20],
                    side: 'side_2.png',
                    pipingColor: '#0000ff',
                    pipingSize: '1'
                };
                roundCakeData['3'] = {
                    size: [18],
                    side: 'side_3.jpg',
                    pipingColor: '#ff0000',
                    pipingSize: '0.8'
                };
                createRoundCake(roundCakeData);
            }

            /*
             * Create Rectangle Cube
             */
            function createRectangleCake(cakeData) {
                var tierWidth, tierDepth;
                var boardWidth, boardDepth, boardPadding, boardHeight;
                boardPadding = 5 * zoomRatio;
                boardHeight = 0.5 * zoomRatio;

                //Load piping image
                var pipingImage = new Image();
                pipingImage.onload = function() {
                    if (cakeData[1]) {
                        tierWidth = cakeData[1].size[0] * zoomRatio;
                        tierDepth = cakeData[1].size[1] * zoomRatio;

                        boardWidth = tierWidth + boardPadding;
                        boardDepth = tierDepth + boardPadding;
                        var boardCube = createRectangleCube(boardWidth, boardDepth, boardHeight, 'board.svg');
                        boardCube.position.set(0, (tierHeight + boardHeight) / -2, 0);

                        var boardTopMaterial = boardCube.material.materials[2];
                        var boardTopCtx = boardTopMaterial.map.image.getContext('2d');
                        scene.add(boardCube);

                        var tier1Cube = createRectangleCube(tierWidth, tierDepth, tierHeight, 'ferg_sidestrip_icing/sidestrip_icing_blue.svg');
                        tier1Cube.position.set(0, 0, 0);

                        var tier1LeftMaterial = tier1Cube.material.materials[0];
                        var tier1TopMaterial = tier1Cube.material.materials[2];
                        var tier1FrontMaterial = tier1Cube.material.materials[4];
                        var tier1SideCtx = tier1LeftMaterial.map.image.getContext('2d');
                        var tier1TopCtx = tier1TopMaterial.map.image.getContext('2d');
                        var tier1FrontCtx = tier1FrontMaterial.map.image.getContext('2d');
                        scene.add(tier1Cube);

                        //Draw side image
                        var tier1Side = new Image();
                        tier1Side.onload = function() {
                            tierWidth = cakeData[1].size[0] * zoomRatio;
                            tierDepth = cakeData[1].size[1] * zoomRatio;

                            var sideImageCanvas = document.createElement("canvas");
                            var sideImageCtx = sideImageCanvas.getContext('2d');
                            sideImageCanvas.width = tierHeight * tier1Side.width / tier1Side.height;
                            sideImageCanvas.height = tierHeight;
                            sideImageCtx.drawImage(tier1Side, 0, 0, tier1Side.width, tier1Side.height, 0, 0, sideImageCanvas.width, sideImageCanvas.height);
                            addSidePiping(sideImageCtx, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
                            var sideImagePattern = sideImageCtx.createPattern(sideImageCanvas, 'repeat');

                            tier1SideCtx.fillStyle = sideImagePattern;
                            tier1SideCtx.fill();
                            tier1LeftMaterial.map.needsUpdate = true;

                            tier1FrontCtx.fillStyle = sideImagePattern;
                            tier1FrontCtx.fill();
                            tier1FrontMaterial.map.needsUpdate = true;

                            addTopPiping(tier1TopCtx, tierWidth, tierDepth, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
                            tier1TopMaterial.map.needsUpdate = true;

                            addBottomPiping(boardTopCtx, boardWidth, boardWidth, tierWidth, tierDepth, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
                            boardTopMaterial.map.needsUpdate = true;

                        };
                        tier1Side.src = cakeData[1].side;
                    }
                };
                pipingImage.src = pipingImg;
            }

            /*
             * Create Square Cube
             */
            function createSquareCake(cakeData) {
//SQUARE CAKES
                var tierWidth;
                var boardWidth, boardPadding, boardHeight;
                boardPadding = 5 * zoomRatio;
                boardHeight = 0.5 * zoomRatio;

                //Load piping image
                var pipingImage = new Image();
                pipingImage.onload = function() {
                    if (cakeData[1]) {
                        tierWidth = cakeData[1].size[0] * zoomRatio;

                        boardWidth = tierWidth + boardPadding;
                        var boardCube = createSquareCube(boardWidth, boardHeight, 'board.svg');
                        boardCube.position.set(0, (tierHeight + boardHeight) / -2, 0);

                        var boardTopMaterial = boardCube.material.materials[2];
                        var boardTopCtx = boardTopMaterial.map.image.getContext('2d');
                        scene.add(boardCube);

                        var tier1Cube = createSquareCube(tierWidth, tierHeight, 'ferg_sidestrip_icing/sidestrip_icing_blue.svg');
                        tier1Cube.position.set(0, 0, 0);

                        var tier1SideMaterial = tier1Cube.material.materials[0];
                        var tier1TopMaterial = tier1Cube.material.materials[2];
                        var tier1SideCtx = tier1SideMaterial.map.image.getContext('2d');
                        var tier1TopCtx = tier1TopMaterial.map.image.getContext('2d');
                        scene.add(tier1Cube);

                        //Draw side image
                        var tier1Side = new Image();
                        tier1Side.onload = function() {
                            tierWidth = cakeData[1].size[0] * zoomRatio;

                            var sideImageCanvas = document.createElement("canvas");
                            var sideImageCtx = sideImageCanvas.getContext('2d');
                            sideImageCanvas.width = tierHeight * tier1Side.width / tier1Side.height;
                            sideImageCanvas.height = tierHeight;
                            sideImageCtx.drawImage(tier1Side, 0, 0, tier1Side.width, tier1Side.height, 0, 0, sideImageCanvas.width, sideImageCanvas.height);
                            addSidePiping(sideImageCtx, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
                            var sideImagePattern = sideImageCtx.createPattern(sideImageCanvas, 'repeat');

                            tier1SideCtx.fillStyle = sideImagePattern;
                            tier1SideCtx.fill();
                            tier1SideMaterial.map.needsUpdate = true;

                            addTopPiping(tier1TopCtx, tierWidth, tierWidth, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
                            tier1TopMaterial.map.needsUpdate = true;

//                            addBottomPiping(boardTopCtx, boardWidth, boardWidth, tierWidth, tierWidth, pipingImage, cakeData[1].pipingSize, cakeData[1].pipingColor);
//                            boardTopMaterial.map.needsUpdate = true;

                        };
                        tier1Side.src = cakeData[1].side;
                        if (cakeData[2]) {
                            tierWidth = cakeData[2].size[0] * zoomRatio;

                            var tier2Cube = createSquareCube(tierWidth, tierHeight, 'ferg_sidestrip_icing/sidestrip_icing_green.svg');
                            tier2Cube.position.set(0, tierHeight, 0);

                            var tier2SideMaterial = tier2Cube.material.materials[0];
                            var tier2TopMaterial = tier2Cube.material.materials[2];
                            var tier2SideCtx = tier2SideMaterial.map.image.getContext('2d');
                            var tier2TopCtx = tier2TopMaterial.map.image.getContext('2d');

                            scene.add(tier2Cube);

                            //Draw Side Image
                            var tier2Side = new Image();
                            tier2Side.onload = function() {
                                tierWidth = cakeData[2].size[0] * zoomRatio;

                                var sideImageCanvas = document.createElement("canvas");
                                var sideImageCtx = sideImageCanvas.getContext('2d');
                                sideImageCanvas.width = tierHeight * tier2Side.width / tier2Side.height;
                                sideImageCanvas.height = tierHeight;
                                sideImageCtx.drawImage(tier2Side, 0, 0, tier2Side.width, tier2Side.height, 0, 0, sideImageCanvas.width, sideImageCanvas.height);
                                addSidePiping(sideImageCtx, pipingImage, cakeData[2].pipingSize, cakeData[2].pipingColor);
                                var sideImagePattern = sideImageCtx.createPattern(sideImageCanvas, 'repeat');

                                tier2SideCtx.fillStyle = sideImagePattern;
                                tier2SideCtx.fill();
                                tier2SideMaterial.map.needsUpdate = true;

                                addTopPiping(tier2TopCtx, tierWidth, tierWidth, pipingImage, cakeData[2].pipingSize, cakeData[2].pipingColor);
                                tier2TopMaterial.map.needsUpdate = true;

//                            addBottomPiping(tier1TopCtx, cakeData[1].size[0] * zoomRatio, cakeData[1].size[0] * zoomRatio, tierWidth, tierWidth, pipingImage, cakeData[2].pipingWidth, cakeData[2].pipingColor);
//                            tier1TopMaterial.map.needsUpdate = true;
                            };
                            tier2Side.src = cakeData[2].side;

                            if (cakeData[3]) {
                                tierWidth = cakeData[3].size[0] * zoomRatio;

                                var tier3Cube = createSquareCube(tierWidth, tierHeight, 'ferg_sidestrip_icing/sidestrip_icing_ivory.svg');
                                tier3Cube.position.set(0, tierHeight * 2, 0);

                                var tier3SideMaterial = tier3Cube.material.materials[0];
                                var tier3TopMaterial = tier3Cube.material.materials[2];
                                var tier3SideCtx = tier3SideMaterial.map.image.getContext('2d');
                                var tier3TopCtx = tier3TopMaterial.map.image.getContext('2d');

                                scene.add(tier3Cube);

                                var tier3Side = new Image();
                                tier3Side.onload = function() {
                                    tierWidth = cakeData[3].size[0] * zoomRatio;

                                    var sideImageCanvas = document.createElement("canvas");
                                    var sideImageCtx = sideImageCanvas.getContext('2d');
                                    sideImageCanvas.width = tierHeight * tier3Side.width / tier3Side.height;
                                    sideImageCanvas.height = tierHeight;
                                    sideImageCtx.drawImage(tier3Side, 0, 0, tier3Side.width, tier3Side.height, 0, 0, sideImageCanvas.width, sideImageCanvas.height);
                                    addSidePiping(sideImageCtx, pipingImage, cakeData[3].pipingSize, cakeData[3].pipingColor);
                                    var sideImagePattern = sideImageCtx.createPattern(sideImageCanvas, 'repeat');

                                    tier3SideCtx.fillStyle = sideImagePattern;
                                    tier3SideCtx.fill();
                                    tier3SideMaterial.map.needsUpdate = true;

                                    addTopPiping(tier3TopCtx, tierWidth, tierWidth, pipingImage, cakeData[3].pipingSize, cakeData[3].pipingColor);
                                    tier3TopMaterial.map.needsUpdate = true;

//                            addBottomPiping(tier2TopCtx, cakeData[2].size[0] * zoomRatio, cakeData[2].size[0] * zoomRatio, tierWidth, tierWidth, pipingImage, cakeData[3].pipingSize, cakeData[3].pipingColor);
//                            tier2TopMaterial.map.needsUpdate = true;
                                };
                                tier3Side.src = cakeData[3].side;
                            }
                        }
                    }
                };
                pipingImage.src = pipingImg;
            }


            /*
             * Create Square Cube
             */
            function createRoundCake(cakeData) {
//ROUND CAKES
                var boardPadding, boardHeight;
                boardPadding = 5 * zoomRatio;
                boardHeight = 0.5 * zoomRatio;

                //Load piping image
                var pipingImage = new Image();
                pipingImage.onload = function() {
                    if (cakeData[1]) {
                        var boardCylinder = createRoundTier(cakeData[1].size[0] * zoomRatio + boardPadding, boardHeight, 'board.svg', 'board.svg');
                        boardCylinder.position.set(0, (tierHeight + boardHeight) / -2, 0);
                        scene.add(boardCylinder);

                        var tier1Cylinder = createRoundTier(cakeData[1].size[0] * zoomRatio, tierHeight, 'top.jpg', cakeData[1].side, pipingImage);
                        tier1Cylinder.position.set(0, 0, 0);
                        scene.add(tier1Cylinder);

                        if (cakeData[2]) {
                            var tier2Cylinder = createRoundTier(cakeData[2].size[0] * zoomRatio, tierHeight, 'top.jpg', cakeData[2].side, pipingImage);
                            tier2Cylinder.position.set(0, tierHeight, 0);
                            scene.add(tier2Cylinder);
                            if (cakeData[3]) {
                                var tier3Cylinder = createRoundTier(cakeData[3].size[0] * zoomRatio, tierHeight, 'top.jpg', cakeData[3].side, pipingImage);
                                tier3Cylinder.position.set(0, tierHeight * 2, 0);
                                scene.add(tier3Cylinder);
                            }
                        }
                    }
                };
                pipingImage.src = 'piping_one.png';
            }

            function addSidePiping(context, piping, pipingWidth, pipingColor) {
                pipingWidth = pipingWidth * zoomRatio;
                var ratio = piping.width / piping.height;

                context.drawImage(piping, 0, 0, piping.width, piping.height, 0, (pipingWidth / -2), ratio * pipingWidth, pipingWidth);
                context.drawImage(piping, 0, 0, piping.width, piping.height, 0, tierHeight + (pipingWidth / -2), ratio * pipingWidth, pipingWidth);

                if (pipingColor) {
                    var buffer = document.createElement('canvas');
                    buffer.width = piping.width;
                    buffer.height = piping.height;
                    var bx = buffer.getContext('2d');
                    bx.fillStyle = pipingColor;
                    bx.fillRect(0, 0, buffer.width, buffer.height);
                    bx.globalCompositeOperation = "destination-atop";
                    bx.drawImage(piping, 0, 0);
                    context.globalAlpha = 0.5;
                    context.drawImage(buffer, 0, 0, piping.width, piping.height, 0, (pipingWidth / -2), ratio * pipingWidth, pipingWidth);
                    context.drawImage(buffer, 0, 0, piping.width, piping.height, 0, tierHeight + (pipingWidth / -2), ratio * pipingWidth, pipingWidth);
                }
            }

            function addTopPiping(context, tierWidth, tierDepth, piping, pipingWidth, pipingColor) {
                pipingWidth = pipingWidth * zoomRatio;
                var ratio = piping.width / piping.height;


                context.drawImage(piping, 0, 0, piping.width, piping.height, 0
                        , -(pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                context.drawImage(piping, 0, 0, piping.width, piping.height, 0
                        , tierDepth - (pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                context.rotate(Math.PI / 2);
                context.drawImage(piping, 0, 0, piping.width, piping.height, 0
                        , -(pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                context.drawImage(piping, 0, 0, piping.width, piping.height, 0
                        , -tierWidth - (pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                context.rotate(Math.PI / -2);

                if (pipingColor) {
                    var buffer = document.createElement('canvas');
                    buffer.width = piping.width;
                    buffer.height = piping.height;
                    var bx = buffer.getContext('2d');
                    bx.fillStyle = pipingColor;
                    bx.fillRect(0, 0, buffer.width, buffer.height);
                    bx.globalCompositeOperation = "destination-atop";
                    bx.drawImage(piping, 0, 0);
                    context.globalAlpha = 0.5;
                    context.drawImage(buffer, 0, 0, piping.width, piping.height
                            , 0, -(pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                    context.drawImage(buffer, 0, 0, piping.width, piping.height
                            , 0, tierDepth - (pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                    context.rotate(Math.PI / 2);
                    context.drawImage(buffer, 0, 0, piping.width, piping.height
                            , 0, -(pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                    context.drawImage(buffer, 0, 0, piping.width, piping.height
                            , 0, -tierWidth - (pipingWidth / 2), ratio * pipingWidth, pipingWidth);
                    context.rotate(Math.PI / -2);
                }
            }

            function addBottomPiping(context, tierWidth, tierDepth, aboveWidth, aboveDepth, piping, pipingSize, pipingColor) {
                var ratio = (aboveWidth + pipingSize) / pipingSize;

                var paddingTop = (tierWidth - aboveWidth - pipingSize) / 2;
                var paddingBottom = (tierWidth - aboveWidth + pipingSize) / 2;
                var paddingLeft = (tierDepth - aboveDepth - pipingSize) / 2;
                var paddingRight = (tierDepth - aboveDepth + pipingSize) / 2;

                context.drawImage(piping, 0, 0, piping.height * ratio, piping.height
                        , paddingTop, paddingTop, pipingSize * ratio, pipingSize);
                context.drawImage(piping, 0, 0, piping.height * ratio, piping.height
                        , paddingTop, tierWidth - paddingBottom, pipingSize * ratio, pipingSize);
                context.rotate(Math.PI / 2);
                context.drawImage(piping, 0, 0, piping.height * ratio, piping.height
                        , paddingLeft, -paddingRight, pipingSize * ratio, pipingSize);
                context.drawImage(piping, 0, 0, piping.height * ratio, piping.height
                        , paddingLeft, -tierWidth + paddingLeft, pipingSize * ratio, pipingSize);
                context.rotate(Math.PI / -2);

                if (pipingColor) {
                    var buffer = document.createElement('canvas');
                    buffer.width = piping.width;
                    buffer.height = piping.height;
                    var bx = buffer.getContext('2d');
                    bx.fillStyle = pipingColor;
                    bx.fillRect(0, 0, buffer.width, buffer.height);
                    bx.globalCompositeOperation = "destination-atop";
                    bx.drawImage(piping, 0, 0);
                    context.globalAlpha = 0.5;
                    context.drawImage(buffer, 0, 0, piping.height * ratio, piping.height
                            , paddingTop, paddingTop, pipingSize * ratio, pipingSize);
                    context.drawImage(buffer, 0, 0, piping.height * ratio, piping.height
                            , paddingTop, tierWidth - paddingBottom, pipingSize * ratio, pipingSize);
                    context.rotate(Math.PI / 2);
                    context.drawImage(buffer, 0, 0, piping.height * ratio, piping.height
                            , paddingTop, -paddingBottom, pipingSize * ratio, pipingSize);
                    context.drawImage(buffer, 0, 0, piping.height * ratio, piping.height
                            , paddingTop, -tierWidth + paddingTop, pipingSize * ratio, pipingSize);
                    context.rotate(Math.PI / -2);
                }
            }

            function createCubeSide(width, height, materialImage) {
                //Create front side
                var cubeSideCanvas = document.createElement("canvas");
//                var cubeSideCanvas = document.getElementById("canvas_container").appendChild(cubeSideCanvas);
                cubeSideCanvas.width = width;
                cubeSideCanvas.height = height;
                var cubeSideTexture = new THREE.Texture(cubeSideCanvas, new THREE.UVMapping());
                cubeSideTexture.needsUpdate = true;
                var cubeSideMaterial = new THREE.MeshBasicMaterial({map: cubeSideTexture});

                var ctx = cubeSideCanvas.getContext('2d');
                ctx.drawSvg(materialImage, 0, 0, width, height);

                return cubeSideMaterial;
            }

            function createCubeTop(width, height, sideimg) {
                //Create front side
                var cubeTopCanvas = document.createElement("canvas");
//                var cubeTopCanvas = document.getElementById("canvas_container").appendChild(cubeTopCanvas);
                cubeTopCanvas.width = width;
                cubeTopCanvas.height = height;
                var cubeTopTexture = new THREE.Texture(cubeTopCanvas, new THREE.UVMapping());
                cubeTopTexture.needsUpdate = true;
                var cubeTopMaterial = new THREE.MeshBasicMaterial({map: cubeTopTexture});

                var ctx = cubeTopCanvas.getContext('2d');
                ctx.drawSvg(sideimg, 0, 0, width, height);

                return cubeTopMaterial;
            }

            function createSquareCube(width, height, sideDesign) {
                var cubeGeometry = new THREE.CubeGeometry(width, height, width);

                var leftMaterial = createCubeSide(width, height, sideDesign);
                var rightMaterial = leftMaterial.clone();
                var frontMaterial = leftMaterial.clone();
                var backMaterial = leftMaterial.clone();
                var topMaterial = createCubeTop(width, width, sideDesign);
                var bottomMaterial = createCubeTop(width, width, sideDesign);

                var faceMatterial = new THREE.MeshFaceMaterial([
                    leftMaterial,
                    rightMaterial,
                    topMaterial,
                    bottomMaterial,
                    frontMaterial,
                    backMaterial
                ]);

                var cube = new THREE.Mesh(cubeGeometry.clone(), faceMatterial);
                return cube;
            }

            function createRectangleCube(width, depth, height, sideDesign) {
                var cubeGeometry = new THREE.CubeGeometry(width, height, depth);

                var leftMaterial = createCubeSide(depth, height, sideDesign);
                var rightMaterial = leftMaterial.clone();
                var topMaterial = createCubeTop(width, depth, sideDesign);
                var bottomMaterial = topMaterial.clone();
                var frontMaterial = createCubeSide(width, height, sideDesign);
                var backMaterial = frontMaterial.clone();

                var faceMatterial = new THREE.MeshFaceMaterial([
                    leftMaterial,
                    rightMaterial,
                    topMaterial,
                    bottomMaterial,
                    frontMaterial,
                    backMaterial
                ]);

                var cube = new THREE.Mesh(cubeGeometry.clone(), faceMatterial);
                return cube;
            }

//            function createRoundCylinder(radius, height, sideDesign) {
//                var cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 100, 1, false);
////                var cubeGeometry = new THREE.CubeGeometry(radius, height, radius);
//
//                var leftMaterial = createCubeSide(radius, height, sideDesign);
//                var rightMaterial = leftMaterial.clone();
//                var frontMaterial = leftMaterial.clone();
//                var backMaterial = leftMaterial.clone();
//                var topMaterial = createCubeTop(radius, radius, sideDesign);
//                var bottomMaterial = createCubeTop(radius, radius, sideDesign);
//
//                var faceMatterial = new THREE.MeshFaceMaterial([
//                    leftMaterial,
//                    rightMaterial,
//                    topMaterial,
//                    bottomMaterial,
//                    frontMaterial,
//                    backMaterial
//                ]);
//
//                var cube = new THREE.Mesh(cylinderGeometry.clone(), faceMatterial);
//                return cube;
//            }

            function createRoundTier(tierSize, tierHeight, topImage, sideImage, pipingImage) {
//                        var pipingSize = 1.2 * zoomRatio;

                var cylinderSideGeometry = new THREE.CylinderGeometry(tierSize, tierSize, tierHeight, 100.0, 10.0, true);
                var cylinderTopGeometry = new THREE.Geometry();
                for (var i = 0; i < 100; i++) {
                    var a = i * 1 / 100 * Math.PI * 2;
                    var z = Math.sin(a);
                    var x = Math.cos(a);
                    var a1 = (i + 1) * 1 / 100 * Math.PI * 2;
                    var z1 = Math.sin(a1);
                    var x1 = Math.cos(a1);
                    cylinderTopGeometry.vertices.push(
                            new THREE.Vector3(0, 0, 0),
                            new THREE.Vector3(x * tierSize, 0, z * tierSize),
                            new THREE.Vector3(x1 * tierSize, 0, z1 * tierSize)
                            );
                    cylinderTopGeometry.faceVertexUvs[0].push([
                        new THREE.Vector2(0.5, 0.5),
                        new THREE.Vector2(x / 2 + 0.5, z / 2 + 0.5),
                        new THREE.Vector2(x1 / 2 + 0.5, z1 / 2 + 0.5)
                    ]);
                    cylinderTopGeometry.faces.push(new THREE.Face3(i * 3, i * 3 + 1, i * 3 + 2));
                }
                cylinderTopGeometry.computeCentroids();
                cylinderTopGeometry.computeFaceNormals();

                var cylinderSideCanvas = document.createElement("canvas");
//                cylinderSideCanvas = document.getElementById("canvas_container").appendChild(cylinderSideCanvas);
                var cylinderSideTexture = new THREE.Texture(cylinderSideCanvas, new THREE.UVMapping());
                var tierSideImage = new Image();

                var cylinderTopCanvas = document.createElement("canvas");
//                cylinderTopCanvas = document.getElementById("canvas_container").appendChild(cylinderTopCanvas);
                var cylinderTopTexture = new THREE.Texture(cylinderTopCanvas, new THREE.UVMapping());
                var tierTopImage = new Image();

                var cylinderSideMaterial = new THREE.MeshLambertMaterial({map: cylinderSideTexture});
                var cylinderSide = new THREE.Mesh(cylinderSideGeometry, cylinderSideMaterial);

                var cylinderTopMaterial = new THREE.MeshLambertMaterial({map: cylinderTopTexture});
                var cylinderTop = new THREE.Mesh(cylinderTopGeometry, cylinderTopMaterial);
                var cylinderBottom = new THREE.Mesh(cylinderTopGeometry, cylinderTopMaterial);

                cylinderTop.rotation.x = Math.PI;

                cylinderTop.position.y = tierHeight / 2;
                cylinderBottom.position.y = -tierHeight / 2;

                var tier1Cylinder = new THREE.Object3D();
                tier1Cylinder.add(cylinderSide);
                tier1Cylinder.add(cylinderTop);
                tier1Cylinder.add(cylinderBottom);
                tier1Cylinder.position.set(0, 0, 0);

                tierSideImage.onload = function() {
                    cylinderSideCanvas.width = tierSideImage.width;
                    cylinderSideCanvas.height = tierSideImage.height;
                    var cylinderSideCtx = cylinderSideCanvas.getContext('2d');
                    if (sideImage.indexOf('svg', sideImage.length - 3) !== -1) {
                        cylinderSideCtx.drawSvg(sideImage, 0, 0);
                    } else {
                        cylinderSideCtx.drawImage(tierSideImage, 0, 0);
                    }

                    tierTopImage.onload = function() {
                        cylinderTopCanvas.width = tierTopImage.width;
                        cylinderTopCanvas.height = tierTopImage.height;
                        var cylinderTopCtx = cylinderTopCanvas.getContext('2d');
                        if (topImage.indexOf('svg', topImage.length - 3) !== -1) {
                            cylinderTopCtx.drawSvg(topImage, 0, 0);
                        } else {
                            cylinderTopCtx.drawImage(tierTopImage, 0, 0);
                        }

                        if (pipingImage) {
                            var topImageRadius = cylinderTopCanvas.width;
                            var tierSize = 2 * Math.PI * topImageRadius;
                            var pipingWidth = pipingImage.width;
                            var pipingNumber = Math.round(tierSize / pipingWidth);
                            var rorateAngle = 2 * Math.PI / pipingNumber;
                            var sideImageWidthStep = cylinderSideCanvas.width / pipingNumber;
                            cylinderTopCtx.translate(topImageRadius / 2, topImageRadius / 2);
                            for (var i = 0; i < pipingNumber; i++) {
                                cylinderTopCtx.drawImage(pipingImage, topImageRadius / 2 - pipingWidth / 2, 0);
                                cylinderTopCtx.rotate(rorateAngle);
                                cylinderSideCtx.drawImage(pipingImage, (i - 1) * sideImageWidthStep, -pipingWidth / 2);
                                cylinderSideCtx.drawImage(pipingImage, (i - 1) * sideImageWidthStep, cylinderSideCanvas.height - pipingWidth / 2);
                            }
                        }
                        cylinderSideTexture.needsUpdate = true;
                        cylinderTopTexture.needsUpdate = true;
                    };
                    tierTopImage.src = topImage;

                    cylinderSideTexture.needsUpdate = true;
                };
                tierSideImage.src = sideImage;

                return tier1Cylinder;
            }

            function animate()
            {
                requestAnimationFrame(animate);
                render();
                update();
            }

            function update()
            {
                if (keyboard.pressed("z"))
                {
                    // do something
                }

                controls.update();
//                stats.update();
            }

            function render()
            {
                renderer.render(scene, camera);
            }

        </script>

    </body>
</html>
